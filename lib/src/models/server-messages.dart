import 'package:tindarts_sdk/src/models/topic-subscription.dart';
import 'package:tindarts_sdk/src/models/delete-transaction.dart';
import 'package:tindarts_sdk/src/models/topic-description.dart';
import 'package:tindarts_sdk/src/models/access-mode.dart';
import 'package:tindarts_sdk/src/models/credential.dart';

class ServerMessage {
  final CtrlMessage? ctrl;
  final MetaMessage? meta;
  final DataMessage? data;
  final PresMessage? pres;
  final InfoMessage? info;

  ServerMessage({this.ctrl, this.meta, this.data, this.pres, this.info});

  static ServerMessage fromMessage(Map<String, dynamic> msg) {
    return ServerMessage(
      ctrl: msg['ctrl'] != null ? CtrlMessage.fromMessage(msg['ctrl'] as Map<String, dynamic>) : null,
      meta: msg['meta'] != null ? MetaMessage.fromMessage(msg['meta'] as Map<String, dynamic>) : null,
      data: msg['data'] != null ? DataMessage.fromMessage(msg['data'] as Map<String, dynamic>) : null,
      pres: msg['pres'] != null ? PresMessage.fromMessage(msg['pres'] as Map<String, dynamic>) : null,
      info: msg['info'] != null ? InfoMessage.fromMessage(msg['info'] as Map<String, dynamic>) : null,
    );
  }
}

class CtrlMessage {
  /// Message Id
  final String? id;

  /// Related topic
  final String? topic;

  /// Message code
  final int? code;

  /// Message text
  final String? text;

  /// Message timestamp
  final DateTime? ts;

  final dynamic params;

  CtrlMessage({
    this.id,
    this.topic,
    this.code,
    this.text,
    this.ts,
    this.params,
  });

  static CtrlMessage fromMessage(Map<String, dynamic> msg) {
    return CtrlMessage(
      id: msg['id'] as String?,
      code: msg['code'] as int?,
      text: msg['text'] as String?,
      topic: msg['topic'] as String?,
      params: msg['params'],
      ts: msg['ts'] as DateTime?,
    );
  }
}

class MetaMessage {
  /// Message Id
  final String? id;

  /// Related topic
  final String? topic;

  /// Message timestamp
  final DateTime? ts;

  /// Topic description, optional
  final TopicDescription? desc;

  ///  topic subscribers or user's subscriptions, optional
  final List<TopicSubscription>? sub;

  /// Array of tags that the topic or user (in case of "me" topic) is indexed by
  final List<String>? tags;

  /// Array of user's credentials
  final List<Credential>? cred;

  /// Latest applicable 'delete' transaction
  final DeleteTransaction? del;

  /// Auxiliary data, writable by topic managers, readable by subscribers
  final Map<String, dynamic>? aux;

  MetaMessage({this.id, this.topic, this.ts, this.desc, this.sub, this.tags, this.cred, this.del, this.aux});

  static MetaMessage fromMessage(Map<String, dynamic> msg) {
    List<dynamic>? sub = msg['sub'] as List<dynamic>?;

    return MetaMessage(
      id: msg['id'] as String?,
      topic: msg['topic'] as String?,
      ts: msg['ts'] as DateTime?,
      desc: msg['desc'] != null ? TopicDescription.fromMessage(msg['desc'] as Map<String, dynamic>) : null,
      sub: sub != null ? sub.map((sub) => TopicSubscription.fromMessage(sub as Map<String, dynamic>)).toList() : [],
      tags: (msg['tags'] as List<dynamic>?)?.cast<String>(),
      cred: msg['cred'] != null && (msg['cred'] as List<dynamic>).isNotEmpty
          ? (msg['cred'] as List<dynamic>).map((dynamic cred) => Credential.fromMessage(cred as Map<String, dynamic>)).toList().cast<Credential>()
          : [],
      del: msg['del'] != null ? DeleteTransaction.fromMessage(msg['del'] as Map<String, dynamic>) : null,
      aux: msg['aux'] as Map<String, dynamic>?,
    );
  }
}

class DataMessage {
  /// topic which distributed this message
  final String? topic;

  /// id of the user who published the message; could be missing if the message was generated by the server
  final String? from;

  /// set of string key-value pairs, passed unchanged from {pub}, optional
  final Map<String, dynamic>? head;

  /// Timestamp
  final DateTime? ts;

  /// Server-issued sequential Id
  int? seq;

  /// object, application-defined content exactly as published by the user in the {pub} message
  final dynamic content;

  bool? noForwarding = false;

  int? hi;

  DataMessage({
    this.topic,
    this.from,
    this.head,
    this.ts,
    this.seq,
    this.content,
    this.noForwarding,
    this.hi,
  });

  static DataMessage fromMessage(Map<String, dynamic> msg) {
    return DataMessage(
      topic: msg['topic'] as String?,
      from: msg['from'] as String?,
      head: msg['head'] as Map<String, dynamic>?,
      ts: msg['ts'] as DateTime?,
      seq: msg['seq'] as int?,
      content: msg['content'],
      noForwarding: (msg['noForwarding'] as bool?) ?? false,
      hi: msg['hi'] as int?,
    );
  }
}

class PresMessage {
  /// Topic which receives the notification, always present
  final String? topic;

  /// Topic or user affected by the change, always present
  final String? src;

  /// what's changed, always present
  final String? what;

  /// "what" is "msg", a server-issued Id of the message, optional
  int? seq;

  /// "what" is "del", an update to the delete transaction Id.
  final int? clear;

  /// Array of ranges, "what" is "del", ranges of Ids of deleted messages, optional
  final List<DeleteTransactionRange>? delseq;

  /// A User Agent string identifying client
  final String? ua;

  /// User who performed the action, optional
  final String? act;

  /// User affected by the action, optional
  final String? tgt;

  /// Changes to access mode, "what" is "acs", optional
  final AccessMode? acs;

  final AccessMode? dacs;

  PresMessage({
    this.topic,
    this.src,
    this.what,
    this.seq,
    this.clear,
    this.delseq,
    this.ua,
    this.act,
    this.tgt,
    this.acs,
    this.dacs,
  });

  static PresMessage fromMessage(Map<String, dynamic> msg) {
    final delseqList = msg['delseq'] as List<dynamic>?;
    return PresMessage(
      topic: msg['msg'] as String?,
      src: msg['src'] as String?,
      what: msg['what'] as String?,
      seq: msg['seq'] as int?,
      clear: msg['clear'] as int?,
      delseq:
          delseqList != null ? delseqList.map((seq) => DeleteTransactionRange.fromMessage(seq as Map<String, dynamic>)).toList() : [],
      ua: msg['ua'] as String?,
      act: msg['act'] as String?,
      tgt: msg['tgt'] as String?,
      acs: msg['acs'] != null ? AccessMode(msg['acs'] as Map<String, dynamic>) : null,
      dacs: msg['dacs'] != null ? AccessMode(msg['dacs'] as Map<String, dynamic>) : null,
    );
  }
}

/// Info message received from server - forwarded client notifications.
///
/// Used for typing notifications, read/recv receipts, and video call signaling.
class InfoMessage {
  /// Topic affected, always present
  final String? topic;

  /// Source topic where the event occurred (present when topic is 'me')
  final String? src;

  /// ID of the user who published the message, always present
  final String? from;

  /// Notification type: 'kp', 'kpa', 'kpv', 'recv', 'read', 'call', 'data'
  final String? what;

  /// ID of the message that client has acknowledged,
  /// guaranteed 0 < read <= recv <= {ctrl.params.seq}; present for recv & read
  final int? seq;

  /// Event type for video calls: 'invite', 'ringing', 'accept', 'answer',
  /// 'offer', 'ice-candidate', 'hang-up'
  final String? event;

  /// Payload data (used for call signaling with SDP/ICE data)
  final Map<String, dynamic>? payload;

  InfoMessage({
    this.topic,
    this.src,
    this.from,
    this.what,
    this.seq,
    this.event,
    this.payload,
  });

  static InfoMessage fromMessage(Map<String, dynamic> msg) {
    return InfoMessage(
      topic: msg['topic'] as String?,
      src: msg['src'] as String?,
      from: msg['from'] as String?,
      what: msg['what'] as String?,
      seq: msg['seq'] as int?,
      event: msg['event'] as String?,
      payload: msg['payload'] as Map<String, dynamic>?,
    );
  }

  /// Check if this is a video call event
  bool get isCallEvent => what == 'call' && event != null;

  /// Check if this is a typing notification
  bool get isTypingNotification =>
      what == 'kp' || what == 'kpa' || what == 'kpv';
}
